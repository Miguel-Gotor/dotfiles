" vimrc
" Display command line tab complete options as a menu
set wildmenu

:colo zaibatsu
" :colo torte
" :colo murphy
" :colo koehler

highlight ColorColumn ctermbg=LightGray guibg=Gray

" Enable type file detection
filetype on

" Enable plugins and load plugin for the detected file type
filetype plugin on

" Auto-complete with Omni completion
set omnifunc=syntaxcomplete#Complete

" Load an indent file for the detected file type
filetype indent on

" Inherit indentation from pervious line when starting writing in a new line
set autoindent

" Turn syntax highlighting on
syntax on

" Add line numbers
set number

" Show relative line numbers
set relativenumber

" Set shift width to 4 spaces
set shiftwidth=4

" Set tab width to 4 columns
set tabstop=4

" Use space characters instead of tabs
set expandtab

" Do not let cursor scroll below or above N number of lines when scrolling
" set scrolloff=100

" Avoid breaking/wrapping lines in the middle of the words
set linebreak

" While searching though a file incrementally highlight matching characters as
" you type
set incsearch

" Make searches case insensitive
set ignorecase

" Override the ignorecase option if searching for capital letters
set smartcase

" Show partial command you type in the last line of the screen
set showcmd

" Show the mode you are on the last line
set showmode

" Show matching words during a search
set showmatch

" Use highlighting when doing a search
set hlsearch

" Have vim use 256-color schemes
" Turns out the following option suffices. No need to override $TERM
set background=dark

" Automatically reload files when modified by an external source
set autoread

" Enable spellchecking
" set spell spelllang=en_us

" Status line From Matjaž (https://github.com/TheMatjaz)
" ------------------------------------------------------------------------------

" Always display the status bar
set laststatus =2

function! Capitalize(string)
    let result = substitute(a:string,'\(\<\w\+\>\)', '\u\1', 'g')
    return result
endfunction

set statusline =

" Buffer number
set statusline +=\ Buffer\ #%n
" Path to the file in the buffer, as typed or relative to current directory
set statusline +=%f
" Flag for modified file
set statusline +=%m

" Padding, empty space in the middle
set statusline+=%=

" File type, encoding and end of line format
set statusline +=\ %Y
set statusline +=\ \|\ %{toupper(&fileencoding?&fileencoding:&encoding)}
set statusline +=\ \|\ %{Capitalize(&fileformat)}
" Current line and column number
set statusline +=\ \|\ %l:%c
" Total lines in file
set statusline +=\ \|\ Lines:\ %L
" Time and date
set statusline +=\ \|\ %{strftime('%a\ %d\ %b,\ %H:%M:%S')}
" Final space on the right side of the screen
set statusline +=\

" Ignore files matching these patterns when opening files based on a glob 
" pattern
set wildignore +=*.pyc  " Python bytecode
set wildignore +=*.swp  " Vim swap files
set wildignore +=*.bak  " Generic backup files
set wildignore +=*.class  " Java bytecode
set wildignore +=.DS_Store  " macOS folder metadata

" Whitespace characters display ------------------------------------------------

" Show soft wraping of the line with this string to indicate
" a visual continuation on the next line.
" Note: a space is the last character in the string.

set showbreak =↪\

" Show whitespace characters with the following characters instead.
" set list
" set listchars =
" set listchars +=tab:⇥\ 
" set listchars +=extends:>
" set listchars +=precedes:<
" set listchars +=nbsp:␣
" set listchars +=trail:•
" set listchars +=eol:↲

" XDG base directory specification  --------------------------------------------

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = "$XDG_DATA_HOME/vim"
call mkdir(expand("$XDG_DATA_HOME/vim/spell"), 'p')

set backupdir=$XDG_STATE_HOME/vim/backup | call mkdir(&backupdir, 'p')
set directory=$XDG_STATE_HOME/vim/swap   | call mkdir(&directory, 'p')
set undodir=$XDG_STATE_HOME/vim/undo     | call mkdir(&undodir,   'p')
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p')

if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif

" Mappings ---------------------------------------------------------------------
" There's no native mapping command that creates the same mapping in both
" Normal and Insert modes :(

" Toggle line comment
vnoremap º :call ToggleComment()<CR>
nnoremap º :call ToggleComment()<CR>
inoremap º <C-o>:call ToggleComment()<CR>

" Cycle through available color schemes
" Previous
nnoremap <F1> :call CycleColorSchemes(-1)<CR>:colo<CR>
inoremap <F1> <C-o>:call CycleColorSchemes(-1)<CR>
" Next
nnoremap <F2> :call CycleColorSchemes(1)<CR>:colo<CR>
inoremap <F2> <C-o>:call CycleColorSchemes(1)<CR>

" Reminder: <F3> is used to toggle UPPERCASE/lowercase

" Reload current file
nnoremap <F4> :w<CR>:e<CR>:echo "File reloaded"<CR>
inoremap <F4> <C-o>:w<CR><C-o>:e<CR>

" Reminder: <F5> and <F6> are used to run/compile/execute based on ft

" Reload vimrc
nnoremap <F7> :source $MYVIMRC<CR>:echo "Vimrc reloaded"<CR>

" Open vimrc
nnoremap <F8> <Esc>:w <CR> :e $MYVIMRC<CR>

" Useful toggles for various settings that are not needed permanently but come 
" in handy at times.

" Toggle spellchecking
nnoremap <F9> :setlocal spell! spell?<CR>
inoremap <F9> <C-o>:setlocal spell! spell?<CR>

" Toggle column highlighting
nnoremap <F10> :if &colorcolumn == '' \| setlocal colorcolumn=81 \| else \| setlocal colorcolumn= \| endif<CR>
inoremap <F10> <C-o>:if &colorcolumn == '' \| setlocal colorcolumn=81 \| else \| setlocal colorcolumn= \| endif<CR>
" 
" Reminder: <F11 is used to toggle fullscreen in i3wm bindsym)

" Toggle line numbering
nnoremap <F12> :if &number == 0 \| setlocal number relativenumber \| else \| setlocal nonumber norelativenumber \| endif<CR>
inoremap <F12> <C-o>:if &number == 0 \| setlocal number relativenumber \| else \| setlocal nonumber norelativenumber \| endif<CR>

" Visual line separator.
inoremap ;- <Esc>:call InsertHyphens()<CR>:startinsert<CR>

" Automatically merge changes in xresources
autocmd BufWritePost $XDG_CONFIG_HOME/X11/xresources silent! execute '!xrdb -merge %' | redraw!

" Separator - Fill with hyphens up to the 80th column
function InsertHyphens()
    let save_cursor = getpos(".")
    let current_column = col('.')
    let hyphens_to_insert = 79 - current_column
    let hyphens = repeat('-', hyphens_to_insert)
    execute "normal! a" . hyphens
    call setpos('.', current_column)
    
endfunction

" Functions
" -----------------------------------------------------------------

function! CycleColorSchemes(inc)

    " g:colors_name is undefined until a color scheme is explicitly set
    let available_schemes = getcompletion('', 'color')
    let current_scheme = exists('g:colors_name') ? g:colors_name : available_schemes[0]
    let next_scheme = ''

    for i in range(len(available_schemes))
        if available_schemes[i] ==# current_scheme
            let next_scheme = available_schemes[(i + a:inc) % len(available_schemes)]
            break
        endif
    endfor

    execute 'colorscheme' next_scheme

endfunction

function! ToggleComment()
    let cursor = getpos(".")
    let line = getline(".")
    let comment_str = ""

    " Define comment string based on file type
    if &ft == 'c'
        let comment_str = '\/\/'
    elseif &ft == 'tex' || &ft == 'matlab'
        let comment_str = '%'
    elseif &ft == 'vim'
        let comment_str = '"'
    elseif &ft == 'python' || &ft == 'conf'
        let comment_str = '#'
    endif

    " Check if the line is already commented
    if line =~ '^\s*' . comment_str . '\s\?'
        " Uncomment
        execute 's/^\(\s*\)' . comment_str . '\s\?/\1/'
        let cursor[2] -= (len(comment_str) + 1)
    else
        " Comment
        execute 's/^\(\s*\)/\1' . comment_str . ' /'
        let cursor[2] += (len(comment_str) + 1)
    endif

    " Account for the comment_str length to restore cursor position
    call setpos('.', cursor)
endfunction

