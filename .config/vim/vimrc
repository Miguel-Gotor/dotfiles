" .config/vim/vimrc

" Force transparent background on st
autocmd ColorScheme *  hi! Normal ctermbg=NONE guibg=NONE
highlight ColorColumn ctermbg=LightGray guibg=Gray
"
if &term =~ '256color'
    set t_ut=
endif

" Underline (rather than highlight) the current line in vim
" ----------------------------------------------------------------------------
" Only in insert mode
" au InsertEnter * set cul
" au InsertLeave * set nocul
" set culopt=screenline
" set culopt=number

" hi clear CursorLine
" hi CursorLine gui=underline cterm=underline ctermfg=NONE guifg=NONE

" Separate commands don't seem to work. Gotta bind it to autocmds and override
" colorscheme settings for all schemes.

autocmd ColorScheme * hi! clear cursorline
autocmd ColorScheme * hi! CursorLine cterm=underline gui=underline ctermfg=NONE guifg=NONE

" Remove trailing whitespaces on file write
autocmd BufWritePre * :%s/\s\+$//e

" Clear jumplist between sessions
au VimEnter * clearjumps

" Enable automatic line wrapping
" autocmd Filetype text set formatoptions+=a

" The screen will not be redrawn while executing macros, registers and other
" commands that have not been typed. Also, updating the window title is
" postponed
" set lazyredraw

" Set the shell used to execute commands
set shell =/bin/sh

" Display command line tab complete options as a menu
set wildmenu

" Enable type file detection
filetype on

" Enable plugins and load plugin for the detected file type
filetype plugin on

" Auto-complete with Omni completion
set omnifunc=syntaxcomplete#Complete

" Load an indent file for the detected file type
filetype indent on

" Inherit indentation from previous line when starting writing in a new line
set autoindent

" Turn syntax highlighting on
syntax on

" Add line numbers
set number

" Show relative line numbers
set relativenumber

" Set shift width to 4 spaces
set shiftwidth=4

" Set tab width to 4 columns
set tabstop=4

" Use space characters instead of tabs
set expandtab

" Do not let cursor scroll below or above N number of lines when scrolling
set scrolloff=8

" Avoid breaking/wrapping lines in the middle of the words
set linebreak

" While searching though a file incrementally highlight matching characters as
" you type
set incsearch

" Make searches case insensitive
set ignorecase

" Override the ignorecase option if searching for capital letters
set smartcase

" Highlight matching parentheses or brackets
set showmatch

" Use highlighting when doing a search
set hlsearch

" Show partial command you type in the last line of the screen
set showcmd

" Show the mode you are on the last line
set showmode

" Have vim use 256-color schemes (cyan/magenta/yellow for default colorscheme)
" Turns out the following option suffices. No need to override $TERM
set bg=dark

" Automatically reload files when modified by an external source
set autoread

" Avoid moving cursor to BOL when jumping around
set nostartofline

" Enable spellchecking
" set spell spelllang=en_us

" From user Matjaž (https://github.com/TheMatjaz)
" *****************************************************************************

" Always display the status bar
set laststatus =2

set statusline =

" Buffer number
set statusline +=\ Buffer\ #%n
" Path to the file in the buffer, as typed or relative to current directory
set statusline +=%f
" Flag for modified file
set statusline +=%m

" Padding, empty space in the middle
set statusline+=%=

" File type, encoding and end of line format
set statusline +=\ %Y
set statusline +=\ \|\ %{toupper(&fileencoding?&fileencoding:&encoding)}
set statusline +=\ \|\ %{toupper(&fileformat)}
" Current line and column number
set statusline +=\ \|\ %l:%c
" Total lines in file
set statusline +=\ \|\ Lines:\ %L
" Time and date
set statusline +=\ \|\ %{strftime('%a\ %d\ %b,\ %H:%M:%S')}
" Final space on the right side of the screen
set statusline +=\

" Ignore files matching these patterns when opening files based on a glob
" pattern
set wildignore +=*.pyc  " Python bytecode
set wildignore +=*.swp  " Vim swap files
set wildignore +=*.bak  " Generic backup files
set wildignore +=*.class  " Java bytecode
set wildignore +=.DS_Store  " macOS folder metadata

" Whitespace characters display ------------------------------------------------

" Show soft wraping of the line with this string to indicate
" a visual continuation on the next line.
" Note: a space is the last character in the string.

" set showbreak =↪\
set showbreak =↪

" Show whitespace characters with the following characters instead.

set listchars +=tab:⇥\

" set listchars +=extends:→
" set listchars +=precedes:←
set listchars +=extends:⇒
set listchars +=precedes:⇐
set listchars +=nbsp:␣
set listchars +=trail:•
set listchars +=lead:•
" set listchars +=eoL:↲
set listchars +=eol:↩

" *****************************************************************************

" XDG base directory specification  --------------------------------------------

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = "$XDG_DATA_HOME/vim"
call mkdir(expand("$XDG_DATA_HOME/vim/spell"), 'p')

set backupdir=$XDG_STATE_HOME/vim/backup | call mkdir(&backupdir, 'p')
set directory=$XDG_STATE_HOME/vim/swap   | call mkdir(&directory, 'p')
set undodir=$XDG_STATE_HOME/vim/undo     | call mkdir(&undodir,   'p')
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p')

if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif

" Mappings --------------------------------------------------------------------

map <S-Insert> <MiddleMouse>
map! <S-Insert> <MiddleMouse>


" Toggle line comment (also in visual mode for block selection)
noremap <silent> º :call ToggleComment()<CR>
inoremap <silent> º <C-o>:call ToggleComment()<CR>

" Cycle through available color schemes
" Previous
nnoremap <silent> <F1> :call CycleColorSchemes(-1)<CR>:colo<CR>
inoremap <silent> <F1> <C-o>:call CycleColorSchemes(-1)<CR>
" Next
nnoremap <silent> <F2> :call CycleColorSchemes(1)<CR>:colo<CR>
inoremap <silent> <F2> <C-o>:call CycleColorSchemes(1)<CR>

" Reminder: <F3> is used to toggle UPPERCASE/lowercase

" Reload current file
nnoremap <silent> <F4> :w<CR>:e<CR>:echo "File reloaded"<CR>
inoremap <silent> <F4> <C-o>:w<CR><C-o>:e<CR>

" Reminder: <F5> and <F6> are used to run/compile/execute based on filetype

" Reload vimrc
nnoremap <silent> <F7> :source $MYVIMRC<CR>:echo "Vimrc reloaded"<CR>

" Open vimrc
nnoremap <silent> <F8> :w <CR> :e $MYVIMRC<CR>

" Useful toggles for various settings that are not needed permanently but come
" in handy at times.
" -----------------------------------------------------------------------------

" Toggle spellchecking
nnoremap <silent> <F9> :setlocal spell!<CR>:setlocal spell?<CR>
inoremap <silent> <F9> <C-o>:setlocal spell!<CR>

" Toggle column highlighting
nnoremap <silent> <F10> :if &colorcolumn == '' \| setlocal colorcolumn=80 \| else \| setlocal colorcolumn= \| endif<CR>
inoremap <silent> <F10> <C-o>:if &colorcolumn == '' \| setlocal colorcolumn=80 \| else \| setlocal colorcolumn= \| endif<CR>

" Reminder: <F11 is used to toggle fullscreen in i3wm bindsym)

" Toggle line numbering
nnoremap <silent> <F12> :setlocal number! relativenumber!<CR>
inoremap <silent> <F12> <C-o>:setlocal number! relativenumber!<CR>

" ...and there's more!

" Toggle line wrapping
nnoremap <silent> <C-F11> :setlocal wrap!<CR>:set wrap?<CR>
inoremap <silent> <C-F11> <C-o>:setlocal wrap!<CR>

" Toggle the display of special characters for formatting
nnoremap <silent> <C-F12> :setlocal list!<CR>:set list?<CR>
inoremap <silent> <C-F12> <C-o>:setlocal list!<CR>

" Visual line separator
inoremap ;- <C-o>:call InsertLine()<CR>

" Automatically merge changes in xresources
autocmd BufWritePost $XDG_CONFIG_HOME/X11/xresources silent! execute '!xrdb -merge %' | redraw!

" Automatically reload i3wm after modifying config file
autocmd BufWritePost $XDG_CONFIG_HOME/i3/config silent! execute '!i3-msg reload' | redraw!

" Switch to the next / previous buffer in queue when opening multiple files
" using Alt + Arrows
nnoremap <M-Left> :N<CR>
nnoremap <M-Right> :n<CR>

" Functions -------------------------------------------------------------------

" Separator - Fill with hyphens up to the 79th column
function InsertLine()
    let save_cursor = getpos(".")
    let current_column = col('.')
    let hyphens_to_insert = 79 - current_column
    let hyphens = repeat('-', hyphens_to_insert)
    execute "normal! a" . hyphens
    call setpos('.', current_column)

endfunction

" Select next/previous color scheme
function! CycleColorSchemes(inc)
    " g:colors_name is undefined until a color scheme is explicitly set
    let available_schemes = getcompletion('', 'color')
    let current_scheme = exists('g:colors_name') ? g:colors_name : available_schemes[0]
    let next_scheme = ''

    for i in range(len(available_schemes))
        if available_schemes[i] ==# current_scheme
            let next_scheme = available_schemes[(i + a:inc) % len(available_schemes)]
            break
        endif
    endfor

    exec 'colorscheme' next_scheme

endfunction

" Commenting lines/blocks of code
augroup commenting_code
    autocmd!

    " Fallback: empty string for unspecified file types
    autocmd FileType * let b:comment_leader = ''

    autocmd FileType sh,python,asm,zsh,conf,fstab,i3config,make,cfg
                                    \   let b:comment_leader = '#'
    autocmd FileType c,cpp              let b:comment_leader = '\/\/'
    autocmd FileType tex                let b:comment_leader = '%'
    autocmd FileType mail               let b:comment_leader = '>'
    autocmd FileType vim                let b:comment_leader = '"'
    autocmd FileType xdefaults          let b:comment_leader = '!!'
augroup END

function! ToggleComment()
    let cursor = getpos(".")
    let line = getline(".")

    " Careful with special characters
    let length = len(substitute(b:comment_leader, '\\', '', 'g')) + 1

    " Check if the line is already commented
    if line =~ '^\s*' . b:comment_leader . '\s\?'
        " Uncomment
        execute 's/^\(\s*\)' . b:comment_leader . '\s\?/\1/'
        let cursor[2] -= length
    else
        " Comment
        execute 's/^\(\s*\)/\1' . b:comment_leader . ' /'
        let cursor[2] += length
    endif

    " Account for the comment_leader length to restore cursor position
    call setpos('.', cursor)
endfunction

" Colors
colorscheme deep-space
" colorscheme darkglass
" colorscheme zmrok
" colorscheme enzyme
