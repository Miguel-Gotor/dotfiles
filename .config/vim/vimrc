" vimrc
" Display command line tab complete options as a menu
set wildmenu

" set colorcolumn=81
highlight ColorColumn ctermbg=LightGray guibg=Gray

" Enable type file detection
filetype on

" Enable plugins and load plugin for the detected file type
filetype plugin on

" Auto-complete with Omni completion
set omnifunc=syntaxcomplete#Complete

" Load an indent file for the detected file type
filetype indent on

" Inherit indentation from pervious line when starting writing in a new line
set autoindent

" Turn syntax highlighting on
syntax on

" Add numbers to each line on the left-hand side
set number

" Show relative line numbers
set relativenumber

" Set shift width to 4 spaces
set shiftwidth=4

" Set tab width to 4 columns
set tabstop=4

" Use space characters instead of tabs
set expandtab

" Do not save backup files
" set nobackup

" Do not let cursor scroll below or above N number of lines when scrolling
set scrolloff=10

" Avoid breaking/wrapping lines in the middle of the words
set linebreak

" While searching though a file incrementally highlight matching characters as
" you type
set incsearch

" Make searches case insensitive
set ignorecase

" Override the ignorecase option if searching for capital letters
set smartcase

" Show partial command you type in the last line of the screen
set showcmd

" Show the mode you are on the last line
set showmode

" Show matching words during a search
set showmatch

" Use highlighting when doing a search
set hlsearch

" Have vim use 256-color schemes
" Turns out the following option suffices. No need to override $TERM
set background=dark

" Automatically reload files when modified by an external source
set autoread

" Enable spellchecking
" set spell spelllang=en_us

" Status line From Matjaž (https://github.com/TheMatjaz)
" ------------------------------------------------------------------------------

" Always display the status bar
set laststatus =2

function! Capitalize(string)
    let result = substitute(a:string,'\(\<\w\+\>\)', '\u\1', 'g')
    return result
endfunction

set statusline =

" Buffer number
set statusline +=\ Buffer\ #%n
" Path to the file in the buffer, as typed or relative to current directory
set statusline +=%f
" Flag for modified file
set statusline +=%m

" Padding, empty space in the middle
set statusline+=%=

" File type, encoding and end of line format
set statusline +=\ %Y
set statusline +=\ \|\ %{toupper(&fileencoding?&fileencoding:&encoding)}
set statusline +=\ \|\ %{Capitalize(&fileformat)}
" Current line and column number
set statusline +=\ \|\ %l:%c
" Total lines in file
set statusline +=\ \|\ Lines:\ %L
" Time and date
set statusline +=\ \|\ %{strftime('%a\ %d\ %b,\ %H:%M:%S')}
" Final space on the right side of the screen
set statusline +=\ 

" Ignore files matching these patterns when opening files based on a glob 
" pattern
set wildignore +=*.pyc  " Python bytecode
set wildignore +=*.swp  " Vim swap files
set wildignore +=*.bak  " Generic backup files
set wildignore +=*.class  " Java bytecode
set wildignore +=.DS_Store  " macOS folder metadata

" Whitespace characters display ------------------------------------------------

" Show soft wraping of the line with this string to indicate
" a visual continuation on the next line.
" Note: a space is the last character in the string.

set showbreak =↪\

" Show whitespace characters with the following characters instead.
" set list
" set listchars =
" set listchars +=tab:⇥\ 
" set listchars +=extends:›
" set listchars +=precedes:‹
" set listchars +=nbsp:␣
" set listchars +=trail:•
" set listchars +=eol:↲

" XDG base directory specification  --------------------------------------------

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = "$XDG_DATA_HOME/vim"
call mkdir(expand("$XDG_DATA_HOME/vim/spell"), 'p')

set backupdir=$XDG_STATE_HOME/vim/backup | call mkdir(&backupdir, 'p')
set directory=$XDG_STATE_HOME/vim/swap   | call mkdir(&directory, 'p')
set undodir=$XDG_STATE_HOME/vim/undo     | call mkdir(&undodir,   'p')
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p')

if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif

" Mappings ---------------------------------------------------------------------
" There's no native mapping command that creates the same mapping in both
" Normal and Insert modes D:

"(<F3> is used to toggle uppercase/lowercase)

" Reload current file
nnoremap <F4> :e<CR>

" Reload vimrc
nnoremap <F7> :source $MYVIMRC<CR>:echo "Vimrc reloaded"<CR>

" Open vimrc
nnoremap <F8> <Esc>:w <CR> :e $MYVIMRC<CR>

" Useful toggles for various settings that are not needed permanently but come 
" in handy at times.

" Toggle spellchecking
nnoremap <F9> :setlocal spell! spell?<CR>

" Toggle column highlighting
nnoremap <F10> :if &colorcolumn == '' \| setlocal colorcolumn=81 \| else \| setlocal colorcolumn= \| endif<CR>

"(<F11> is used to toggle fullscreen in i3wm bindsym)

" Toggle line numbering

map <F12> :if &number == 0 \| setlocal number relativenumber \| else \| setlocal nonumber norelativenumber \| endif<CR>

" Visual line separator

" inoremap ;- <Esc>:call InsertHyphens()<CR>:startinsert<CR>

" Automatically merge changes in xresources
autocmd BufWritePost ~/.config/X11/xresources !xrdb -merge  ~/.config/X11/xresources
" autocmd BufWritePost ~/.config/X11/xresources silent! execute '!xrdb -merge ~/.config/X11/xresources' | redraw!

nnoremap <F2> :call CycleColorSchemes()<CR>:colo<CR>

" Separator - Fill with hyphens up to the 80th column
function InsertHyphens()
    let current_column = col('.')
    let hyphens_to_insert = 79 - current_column
    let hyphens = repeat('-', hyphens_to_insert)
    execute "normal! a" . hyphens
endfunction

" Cycle through available color schemes
function! CycleColorSchemes()
    let current_scheme = g:colors_name
    let available_schemes = getcompletion('', 'color')
    let next_scheme = ''

    for i in range(len(available_schemes))
        if available_schemes[i] ==# current_scheme
            let next_scheme = available_schemes[(i + 1) % len(available_schemes)]
            break
        endif
    endfor

    if empty(next_scheme)
        " If we reached the end of the list, loop back to the first scheme
        let next_scheme = available_schemes[0]
    endif

    execute 'colorscheme' next_scheme

endfunction

